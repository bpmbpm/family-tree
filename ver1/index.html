<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–µ–º–µ–π–Ω–æ–µ –¥—Ä–µ–≤–æ –Ω–∞ excel + Graphviz (—Å —Ñ–æ—Ç–æ)</title>
    <script src="https://unpkg.com/@viz-js/viz@3.4.0/lib/viz-standalone.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f0f2f5; }
        .container { max-width: 1400px; margin: 0 auto; }
        .toolbar { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { padding: 8px 16px; background: #2c3e50; color: white; border: none; border-radius: 6px; cursor: pointer; }
        button:hover { background: #1e2b37; }
        button:disabled { background: #95a5a6; cursor: not-allowed; }
        #fileInput { display: none; }
        .status { padding: 10px 15px; background: #fff8e5; border-left: 5px solid #f1c40f; margin-bottom: 20px; }
        .info-panels { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
        .panel { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: hidden; }
        .panel-header { background: #e9ecef; padding: 10px 15px; font-weight: 600; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .panel-header:hover { background: #dee2e6; }
        .panel-header .toggle-icon { font-size: 1.2em; }
        .panel-content { padding: 15px; border-top: 1px solid #ddd; display: none; }
        .panel-content.visible { display: block; }
        .photos-grid { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-start; }
        .photo-item { text-align: center; }
        .photo-item img { width: 60px; height: 60px; object-fit: cover; border-radius: 8px; border: 2px solid #ccc; background: #f8f9fa; display: block; }
        .photo-item .path { font-family: monospace; font-size: 11px; margin-top: 4px; color: #495057; max-width: 80px; word-break: break-all; }
        .dot-code { background: #f8f9fa; padding: 10px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; white-space: pre-wrap; max-height: 300px; overflow: auto; border: 1px solid #ced4da; }
        .link-box { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .link-box input { flex: 1; min-width: 300px; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; font-family: monospace; font-size: 13px; background: #f8f9fa; }
        .link-box button { padding: 6px 12px; font-size: 13px; }
        footer { margin-top: 25px; text-align: center; color: #5d6d7e; font-size: 0.9rem; }

        /* Diagram panel */
        .diagram-panel { background: white; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); overflow: hidden; margin-bottom: 20px; display: flex; flex-direction: column; }
        .diagram-panel-header { background: #e9ecef; padding: 10px 15px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .diagram-panel-title { font-size: 1.05em; }

        /* Zoom container */
        .zoom-container {
            position: relative;
            overflow: auto;
            min-height: 500px;
            max-height: 80vh;
            background: white;
            padding: 10px;
            flex: 1;
        }
        .zoom-content {
            transform-origin: top left;
            transition: transform 0.15s ease;
            display: inline-block;
        }
        .zoom-content svg {
            display: block;
        }

        /* Zoom controls ‚Äî at the bottom of diagram panel */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        .zoom-controls button {
            padding: 5px 12px;
            font-size: 14px;
            background: #607D8B;
        }
        .zoom-controls button:hover { background: #455A64; }
        .zoom-controls span {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #333;
            font-size: 13px;
        }

        /* Properties panel (–°–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã) */
        #properties-panels-container {
            position: fixed;
            top: 0; left: 0;
            width: 0; height: 0;
            pointer-events: none;
            z-index: 2000;
        }
        .properties-panel {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 280px;
            max-width: 400px;
            pointer-events: all;
            z-index: 2000;
        }
        .properties-panel.visible { display: block; }
        .properties-header {
            background: #2c3e50;
            color: white;
            padding: 10px 12px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .properties-header-content { flex: 1; }
        .properties-header-title { font-size: 11px; opacity: 0.8; margin-bottom: 4px; }
        .properties-header h3 { margin: 0; font-size: 14px; font-weight: 600; }
        .properties-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
            opacity: 0.8;
        }
        .properties-close-btn:hover { opacity: 1; background: none; }
        .properties-content {
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .property-item { margin-bottom: 8px; }
        .property-predicate { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 2px; }
        .property-value { font-size: 13px; color: #333; word-break: break-all; }
        .property-value.photo { margin-top: 6px; }
        .property-value.photo img { width: 80px; height: 80px; object-fit: cover; border-radius: 6px; border: 2px solid #ccc; }
        .properties-empty { color: #888; font-style: italic; font-size: 13px; }
        .properties-copy-btn {
            background: #607D8B;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 4px;
            margin-top: 4px;
            cursor: pointer;
        }
        .properties-copy-btn:hover { background: #455A64; }

        /* Node hover/selected style */
        .node { cursor: pointer; }
        .node:hover polygon, .node:hover ellipse, .node:hover path, .node:hover rect {
            stroke-width: 3 !important;
            stroke: #e67e22 !important;
        }
        .node.selected polygon, .node.selected ellipse, .node.selected path, .node.selected rect {
            stroke-width: 3 !important;
            stroke: #e74c3c !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üå≥ –°–µ–º–µ–π–Ω–æ–µ –¥—Ä–µ–≤–æ –Ω–∞ excel + Graphviz (—Å —Ñ–æ—Ç–æ)</h1>
        <div class="toolbar">
            <button id="loadBtn">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å tree.xlsx</button>
            <button id="manualBtn">üìÅ –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</button>
            <button id="graphvizOnlineBtn" disabled>üîó –ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ GraphvizOnline</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls">
        </div>
        <div id="status" class="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞...</div>

        <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ -->
        <div class="info-panels">
            <div class="panel" id="panel-link">
                <div class="panel-header" onclick="togglePanel('panel-link-content')">
                    <span>üîó –°—Å—ã–ª–∫–∞ –Ω–∞ GraphvizOnline</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-link-content">
                    <div class="link-box">
                        <input type="text" id="graphvizLinkInput" readonly value="(—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)" />
                        <button onclick="copyLink()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                    </div>
                </div>
            </div>

            <div class="panel" id="panel-placeholders">
                <div class="panel-header" onclick="togglePanel('panel-placeholders-content')">
                    <span>üñºÔ∏è –§–æ—Ç–æ –ø–µ—Ä—Å–æ–Ω</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-placeholders-content">
                    <div class="photos-grid" id="photosGrid">
                        <em style="color:#888">–ó–∞–≥—Ä—É–∑–∏—Ç–µ Excel –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–æ—Ç–æ</em>
                    </div>
                </div>
            </div>

            <div class="panel" id="panel-code">
                <div class="panel-header" onclick="togglePanel('panel-code-content')">
                    <span>üìÑ –ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ DOT (–Ω–µ—Å–∂–∞—Ç—ã–π)</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-code-content">
                    <pre id="dotCodePre" class="dot-code">(–∫–æ–¥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)</pre>
                </div>
            </div>
        </div>

        <!-- Diagram panel: zoom container on top, zoom controls at bottom -->
        <div class="diagram-panel">
            <div class="diagram-panel-header">
                <span class="diagram-panel-title">üìä –î–∏–∞–≥—Ä–∞–º–º–∞</span>
            </div>
            <div class="zoom-container" id="zoomContainer">
                <div class="zoom-content" id="zoomContent">
                    <div id="graphvizContainer">–î–µ—Ä–µ–≤–æ –±—É–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–æ –∑–¥–µ—Å—å...</div>
                </div>
            </div>
            <div class="zoom-controls" id="zoom-controls">
                <button onclick="zoomIn()" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
                <span id="zoom-level">100%</span>
                <button onclick="zoomOut()" title="–£–º–µ–Ω—å—à–∏—Ç—å">‚àí</button>
                <button onclick="zoomReset()" title="–°–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—à—Ç–∞–±">–°–±—Ä–æ—Å</button>
                <button onclick="zoomFit()" title="–í–ø–∏—Å–∞—Ç—å –≤ –æ–∫–Ω–æ">–í–ø–∏—Å–∞—Ç—å</button>
            </div>
        </div>

        <footer>–§–æ—Ç–æ –∏–∑ –ø–∞–ø–∫–∏ <code>pic/</code> (idA.png). –î–ª—è –º—É–∂—á–∏–Ω —Ä–∞–º–∫–∞ —Å–∏–Ω—è—è, –¥–ª—è –∂–µ–Ω—â–∏–Ω ‚Äî —Ä–æ–∑–æ–≤–∞—è. –ì–æ–¥—ã –Ω–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ.</footer>
    </div>

    <!-- Properties panels container (fixed positioning) -->
    <div id="properties-panels-container"></div>

    <script>
        (function() {
            let people = [];
            let dotCode = '';
            let graphvizLink = '';
            let currentScale = 1.0;

            // Properties panel state
            let openPropertiesPanels = [];
            let propertiesPanelCounter = 0;
            let selectedNodeElement = null;
            let draggedPanel = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            // Cache: filename -> true (exists) or false (not found)
            const photoExistsCache = {};

            const graphvizOnlineBtn = document.getElementById('graphvizOnlineBtn');
            const statusDiv = document.getElementById('status');
            const graphvizContainer = document.getElementById('graphvizContainer');
            const zoomContent = document.getElementById('zoomContent');
            const zoomContainer = document.getElementById('zoomContainer');
            const zoomLevelSpan = document.getElementById('zoom-level');
            const loadBtn = document.getElementById('loadBtn');
            const manualBtn = document.getElementById('manualBtn');
            const fileInput = document.getElementById('fileInput');
            const graphvizLinkInput = document.getElementById('graphvizLinkInput');
            const dotCodePre = document.getElementById('dotCodePre');

            // --- Panel toggling ---
            window.togglePanel = function(contentId) {
                const content = document.getElementById(contentId);
                const icon = content.previousElementSibling.querySelector('.toggle-icon');
                content.classList.toggle('visible');
                icon.textContent = content.classList.contains('visible') ? '‚ñº' : '‚ñ∂';
            };

            window.copyLink = function() {
                graphvizLinkInput.select();
                document.execCommand('copy');
                alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
            };

            // --- Zoom controls ---
            function applyZoom() {
                zoomContent.style.transform = `scale(${currentScale})`;
                zoomLevelSpan.textContent = Math.round(currentScale * 100) + '%';
            }

            window.zoomIn = function() {
                if (currentScale < 5.0) { currentScale = Math.min(5.0, currentScale + 0.1); applyZoom(); }
            };
            window.zoomOut = function() {
                if (currentScale > 0.1) { currentScale = Math.max(0.1, currentScale - 0.1); applyZoom(); }
            };
            window.zoomReset = function() {
                currentScale = 1.0;
                applyZoom();
            };
            window.zoomFit = function() {
                const svg = graphvizContainer.querySelector('svg');
                if (!svg) return;
                const containerW = zoomContainer.clientWidth - 20;
                const containerH = zoomContainer.clientHeight - 20;
                const svgW = svg.getBoundingClientRect().width / currentScale;
                const svgH = svg.getBoundingClientRect().height / currentScale;
                if (svgW <= 0 || svgH <= 0) return;
                const scaleX = containerW / svgW;
                const scaleY = containerH / svgH;
                currentScale = Math.min(scaleX, scaleY, 1.0);
                applyZoom();
            };

            // Mouse wheel zoom
            zoomContainer.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                currentScale = Math.min(5.0, Math.max(0.1, currentScale + delta));
                applyZoom();
            }, { passive: false });

            // --- Status ---
            function showStatus(msg, isError = false) {
                statusDiv.textContent = msg;
                statusDiv.style.backgroundColor = isError ? '#fadbd8' : '#fff8e5';
                statusDiv.style.borderLeftColor = isError ? '#e74c3c' : '#f1c40f';
            }

            // --- Check if photo exists via HEAD request ---
            async function checkPhotoExists(filename) {
                if (photoExistsCache[filename] !== undefined) return photoExistsCache[filename];
                try {
                    const response = await fetch('pic/' + filename, { method: 'HEAD' });
                    photoExistsCache[filename] = response.ok;
                    return response.ok;
                } catch {
                    photoExistsCache[filename] = false;
                    return false;
                }
            }

            // --- Determine which photo file to use for a person (returns filename or null) ---
            async function getPersonPhotoFile(person) {
                const personalFile = person.idA + '.png';
                if (await checkPhotoExists(personalFile)) return personalFile;
                // Fall back to default
                const defaultFile = (person.sex === '–ñ' || person.sex === 'F') ? 'dafaultf.png' : 'dafaultm.png';
                if (await checkPhotoExists(defaultFile)) return defaultFile;
                return null;
            }

            // --- Preload / check photo existence for all people ---
            async function preloadPhotoChecks(peopleList) {
                const filenames = new Set(['dafaultm.png', 'dafaultf.png']);
                peopleList.forEach(p => { if (p.idA) filenames.add(p.idA + '.png'); });
                await Promise.all(Array.from(filenames).map(fn => checkPhotoExists(fn)));
            }

            // --- Parse Excel ---
            function parseExcel(arrayBuffer) {
                try {
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const sheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('person')) || workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
                    if (rows.length < 2) throw new Error('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –ª–∏—Å—Ç–µ person');
                    const dataRows = rows.slice(1).filter(row => row[1] && row[1].toString().trim() !== '');
                    const peopleList = dataRows.map(row => ({
                        idA: row[0] ? row[0].toString().trim() : '',
                        label: row[1] ? row[1].toString().trim() : '',
                        sex: row[2] ? row[2].toString().trim() : '',
                        hasFather: row[4] ? row[4].toString().trim() : '',
                        hasMother: row[5] ? row[5].toString().trim() : '',
                        birth: row[6] ? row[6].toString().trim() : '',
                        death: row[7] ? row[7].toString().trim() : ''
                    })).filter(p => p.idA && p.label);
                    if (peopleList.length === 0) throw new Error('–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π —Å idA –∏ label');
                    return peopleList;
                } catch (e) {
                    showStatus('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ Excel: ' + e.message, true);
                    throw e;
                }
            }

            // --- Generate DOT code using Graphviz image attribute ---
            // Uses the standard Graphviz image= attribute for photo embedding in nodes.
            // Photos are loaded from pic/ folder using relative paths.
            async function generateDotCode(peopleList) {
                const nodes = [];
                const edges = [];
                const coupleSet = new Set();

                const maleColor = "#a3c4f3";
                const femaleColor = "#fbb9c0";
                const unknownColor = "#d5d8dc";

                for (const p of peopleList) {
                    const birthYear = p.birth || '?';
                    const deathYear = p.death || '?';

                    let fillcolor = unknownColor;
                    if (p.sex === '–ú' || p.sex === 'M') fillcolor = maleColor;
                    else if (p.sex === '–ñ' || p.sex === 'F') fillcolor = femaleColor;

                    const nodeId = p.idA;
                    const label = `${p.label}\\n(${birthYear}‚Äì${deathYear})`;

                    // Check if person has a photo available (used by injectPhotosIntoSvg after rendering).
                    // Note: Graphviz image= attribute does NOT work in browser WASM rendering context.
                    // Photos are injected into the SVG after rendering via injectPhotosIntoSvg().
                    const photoFile = await getPersonPhotoFile(p);
                    if (photoFile) {
                        // Extra width/height and left margin to make room for the photo (injected post-render)
                        nodes.push(`  ${nodeId} [shape=box, style="filled,rounded", fillcolor="${fillcolor}", color="#2c3e50", fontname="Arial", fontsize=11, label="${label}", width=2.5, height=0.9, fixedsize=false, margin="0.9,0.15"];`);
                    } else {
                        nodes.push(`  ${nodeId} [shape=box, style="filled,rounded", fillcolor="${fillcolor}", color="#2c3e50", fontname="Arial", fontsize=11, label="${label}"];`);
                    }
                }

                // Parent relationships
                peopleList.forEach(p => {
                    const childId = p.idA;
                    if (p.hasFather) edges.push(`  ${p.hasFather} -> ${childId};`);
                    if (p.hasMother) edges.push(`  ${p.hasMother} -> ${childId};`);
                    if (p.hasFather && p.hasMother) {
                        const key = p.hasFather < p.hasMother ? `${p.hasFather}|${p.hasMother}` : `${p.hasMother}|${p.hasFather}`;
                        coupleSet.add(key);
                    }
                });

                // Couple links
                coupleSet.forEach(couple => {
                    const [a, b] = couple.split('|');
                    edges.push(`  ${a} -> ${b} [dir=none, color="#5d6d7e"];`);
                });

                return `digraph G {\n  rankdir=TB;\n  node [fontname="Arial", fontsize=11];\n  edge [color="#5d6d7e"];\n\n${nodes.join('\n')}\n\n${edges.join('\n')}\n}`;
            }

            // --- Load image as base64 data URL ---
            async function loadImageAsDataUrl(src) {
                try {
                    const response = await fetch(src);
                    if (!response.ok) return null;
                    const blob = await response.blob();
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = () => resolve(null);
                        reader.readAsDataURL(blob);
                    });
                } catch {
                    return null;
                }
            }

            // --- Inject photos into rendered SVG nodes ---
            // After Graphviz renders SVG, the image= attribute does not work in browser WASM context.
            // We post-process the SVG: find each node by its title, load its photo via fetch,
            // and inject an <image> element with a base64 data URL into the node group.
            async function injectPhotosIntoSvg(svgEl) {
                const IMG_SIZE = 45;
                const IMG_MARGIN = 6;

                const nodeGroups = svgEl.querySelectorAll('g.node');

                for (const nodeGroup of nodeGroups) {
                    const titleEl = nodeGroup.querySelector('title');
                    if (!titleEl) continue;
                    const nodeId = titleEl.textContent.trim();
                    const person = people.find(p => p.idA === nodeId);
                    if (!person) continue;

                    const photoFile = await getPersonPhotoFile(person);
                    if (!photoFile) continue;

                    const dataUrl = await loadImageAsDataUrl('pic/' + photoFile);
                    if (!dataUrl) continue;

                    // Find the bounding polygon/rect of the node
                    const shape = nodeGroup.querySelector('polygon, ellipse, rect, path');
                    if (!shape) continue;

                    const bbox = shape.getBBox();
                    if (!bbox || bbox.width === 0) continue;

                    // Create SVG <image> element positioned inside the node (left side)
                    const imgX = bbox.x + IMG_MARGIN;
                    const imgY = bbox.y + (bbox.height - IMG_SIZE) / 2;

                    const svgImg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    svgImg.setAttribute('x', imgX);
                    svgImg.setAttribute('y', imgY);
                    svgImg.setAttribute('width', IMG_SIZE);
                    svgImg.setAttribute('height', IMG_SIZE);
                    svgImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    svgImg.setAttribute('href', dataUrl);

                    // Add a clipPath for rounded corners on the image
                    const defs = svgEl.querySelector('defs') || svgEl.insertBefore(
                        document.createElementNS('http://www.w3.org/2000/svg', 'defs'),
                        svgEl.firstChild
                    );
                    const clipId = 'photo-clip-' + nodeId.replace(/[^a-zA-Z0-9]/g, '_');
                    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                    clipPath.setAttribute('id', clipId);
                    const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    clipRect.setAttribute('x', imgX);
                    clipRect.setAttribute('y', imgY);
                    clipRect.setAttribute('width', IMG_SIZE);
                    clipRect.setAttribute('height', IMG_SIZE);
                    clipRect.setAttribute('rx', 5);
                    clipPath.appendChild(clipRect);
                    defs.appendChild(clipPath);
                    svgImg.setAttribute('clip-path', `url(#${clipId})`);

                    // Insert image before first text element so text renders on top
                    const firstText = nodeGroup.querySelector('text');
                    if (firstText) {
                        nodeGroup.insertBefore(svgImg, firstText);
                    } else {
                        nodeGroup.appendChild(svgImg);
                    }

                    // Shift text elements to the right to avoid overlap with image
                    const textShift = IMG_SIZE + IMG_MARGIN * 2;
                    const textEls = nodeGroup.querySelectorAll('text');
                    textEls.forEach(t => {
                        const curX = parseFloat(t.getAttribute('x') || '0');
                        t.setAttribute('x', curX + textShift / 2);
                        // Also update tspan x attributes
                        t.querySelectorAll('tspan').forEach(ts => {
                            const tsX = parseFloat(ts.getAttribute('x') || '0');
                            ts.setAttribute('x', tsX + textShift / 2);
                        });
                    });
                }
            }

            // --- Render DOT code ---
            async function renderDot(dotStr) {
                try {
                    const viz = await Viz.instance();
                    const svgStr = await viz.renderString(dotStr, { format: 'svg' });
                    graphvizContainer.innerHTML = svgStr;

                    // Add node click handlers
                    const svgEl = graphvizContainer.querySelector('svg');
                    if (svgEl) {
                        addNodeClickHandlers(svgEl);
                        // Inject photos into SVG nodes (Graphviz image= attr doesn't work in browser WASM)
                        await injectPhotosIntoSvg(svgEl);
                    }
                } catch (error) {
                    graphvizContainer.innerHTML = `<p style="color:red">–û—à–∏–±–∫–∞ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞: ${error.message}</p>`;
                    console.error(error);
                }
            }

            // --- Update photos panel ---
            // Shows only files that actually exist in pic/ folder (no empty placeholders).
            function updatePhotosPanel() {
                const grid = document.getElementById('photosGrid');
                grid.innerHTML = '';

                // Build list of files that were checked and found to exist
                const existingFiles = [];

                // Always include defaults if they exist
                for (const fn of ['dafaultm.png', 'dafaultf.png']) {
                    if (photoExistsCache[fn]) existingFiles.push(fn);
                }

                // Add person photos that exist
                people.forEach(p => {
                    const fn = p.idA + '.png';
                    if (photoExistsCache[fn] && !existingFiles.includes(fn)) {
                        existingFiles.push(fn);
                    }
                });

                if (existingFiles.length === 0) {
                    grid.innerHTML = '<em style="color:#888">–§–∞–π–ª—ã —Ñ–æ—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –ø–∞–ø–∫–µ pic/</em>';
                    return;
                }

                existingFiles.forEach(filename => {
                    const div = document.createElement('div');
                    div.className = 'photo-item';

                    const img = document.createElement('img');
                    img.src = 'pic/' + filename;
                    img.alt = filename;
                    img.title = filename;

                    const label = document.createElement('div');
                    label.className = 'path';
                    const shortName = filename.length > 20 ? filename.substring(0, 18) + '‚Ä¶' : filename;
                    label.textContent = shortName;
                    label.title = filename;

                    div.appendChild(img);
                    div.appendChild(label);
                    grid.appendChild(div);
                });
            }

            // --- Update info panels ---
            function updateInfoPanels() {
                if (dotCode) {
                    dotCodePre.textContent = dotCode;
                    const encoded = encodeURIComponent(dotCode);
                    graphvizLink = `https://dreampuf.github.io/GraphvizOnline/?engine=dot#${encoded}`;
                    graphvizLinkInput.value = graphvizLink;
                } else {
                    dotCodePre.textContent = '(–∫–æ–¥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)';
                    graphvizLinkInput.value = '(—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)';
                }
                updatePhotosPanel();
            }

            // ================================================================
            // PROPERTIES PANEL (–°–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã)
            // Based on rdf-grapher ver9d implementation
            // ================================================================

            function showNodeProperties(person) {
                const container = document.getElementById('properties-panels-container');
                if (!container) return;

                // If already open for this person, bring to front
                const existingPanel = openPropertiesPanels.find(p => p.idA === person.idA);
                if (existingPanel) {
                    const panel = document.getElementById(existingPanel.panelId);
                    if (panel) bringPanelToFront(panel);
                    return;
                }

                propertiesPanelCounter++;
                const panelId = 'properties-panel-' + propertiesPanelCounter;

                const offsetMultiplier = openPropertiesPanels.length % 5;
                const rightOffset = 20 + (offsetMultiplier * 30);
                const topOffset = 100 + (offsetMultiplier * 30);

                // Build properties content
                const sex = person.sex || '‚Äî';
                const birth = person.birth || '‚Äî';
                const death = person.death || '‚Äî';
                const photoFile = photoExistsCache[person.idA + '.png'] ? person.idA + '.png' : null;

                let propertiesHtml = '';
                propertiesHtml += `<div class="property-item"><div class="property-predicate">ID</div><div class="property-value">${person.idA}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ò–º—è</div><div class="property-value">${person.label}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ü–æ–ª</div><div class="property-value">${sex}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ì–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è</div><div class="property-value">${birth}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ì–æ–¥ —Å–º–µ—Ä—Ç–∏</div><div class="property-value">${death}</div></div>`;
                if (person.hasFather) {
                    const father = people.find(p => p.idA === person.hasFather);
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–û—Ç–µ—Ü</div><div class="property-value">${father ? father.label : person.hasFather}</div></div>`;
                }
                if (person.hasMother) {
                    const mother = people.find(p => p.idA === person.hasMother);
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–ú–∞—Ç—å</div><div class="property-value">${mother ? mother.label : person.hasMother}</div></div>`;
                }
                if (photoFile) {
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–§–æ—Ç–æ</div><div class="property-value photo"><img src="pic/${photoFile}" alt="${person.label}"></div></div>`;
                }

                const escapedLabel = person.label.replace(/'/g, "\\'").replace(/"/g, '&quot;');

                const panelHtml = `
                    <div class="properties-panel visible" id="${panelId}" style="right: ${rightOffset}px; top: ${topOffset}px;">
                        <div class="properties-header" onmousedown="startDragPanel(event, '${panelId}')">
                            <div class="properties-header-content">
                                <div class="properties-header-title">–°–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã</div>
                                <h3>${person.label}</h3>
                                <button class="properties-copy-btn" onclick="event.stopPropagation(); copyObjectId('${escapedLabel}', this)">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                            </div>
                            <button class="properties-close-btn" onclick="closePropertiesPanel('${panelId}')">&times;</button>
                        </div>
                        <div class="properties-content">
                            ${propertiesHtml}
                        </div>
                    </div>
                `;

                container.insertAdjacentHTML('beforeend', panelHtml);
                openPropertiesPanels.push({ panelId: panelId, idA: person.idA });

                const newPanel = document.getElementById(panelId);
                if (newPanel) bringPanelToFront(newPanel);
            }

            window.closePropertiesPanel = function(panelId) {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.remove();
                    openPropertiesPanels = openPropertiesPanels.filter(p => p.panelId !== panelId);
                }
                if (selectedNodeElement) {
                    selectedNodeElement.classList.remove('selected');
                    selectedNodeElement = null;
                }
            };

            window.copyObjectId = function(label, btn) {
                navigator.clipboard.writeText(label).then(() => {
                    const orig = btn.textContent;
                    btn.textContent = '‚úì';
                    setTimeout(() => { btn.textContent = orig; }, 1500);
                }).catch(() => {
                    // Fallback
                    const el = document.createElement('textarea');
                    el.value = label;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                });
            };

            function bringPanelToFront(panel) {
                let maxZIndex = 2000;
                openPropertiesPanels.forEach(p => {
                    const el = document.getElementById(p.panelId);
                    if (el) {
                        const z = parseInt(el.style.zIndex) || 2000;
                        if (z > maxZIndex) maxZIndex = z;
                    }
                });
                panel.style.zIndex = maxZIndex + 1;
            }

            window.startDragPanel = function(event, panelId) {
                if (event.target.classList.contains('properties-close-btn') ||
                    event.target.classList.contains('properties-copy-btn')) return;
                const panel = document.getElementById(panelId);
                if (!panel) return;

                draggedPanel = panel;
                const rect = panel.getBoundingClientRect();
                dragOffsetX = event.clientX - rect.left;
                dragOffsetY = event.clientY - rect.top;

                bringPanelToFront(panel);
                document.addEventListener('mousemove', dragPanel);
                document.addEventListener('mouseup', stopDragPanel);
                event.preventDefault();
            };

            function dragPanel(event) {
                if (!draggedPanel) return;
                const newLeft = event.clientX - dragOffsetX;
                const newTop = event.clientY - dragOffsetY;
                draggedPanel.style.left = newLeft + 'px';
                draggedPanel.style.top = newTop + 'px';
                draggedPanel.style.right = 'auto';
            }

            function stopDragPanel() {
                draggedPanel = null;
                document.removeEventListener('mousemove', dragPanel);
                document.removeEventListener('mouseup', stopDragPanel);
            }

            // --- Add node click handlers to rendered SVG ---
            function addNodeClickHandlers(svgEl) {
                const nodes = svgEl.querySelectorAll('g.node');
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    node.addEventListener('click', function(event) {
                        event.stopPropagation();

                        const titleEl = node.querySelector('title');
                        if (!titleEl) return;
                        const nodeId = titleEl.textContent.trim();
                        const person = people.find(p => p.idA === nodeId);
                        if (!person) return;

                        // Update selection highlight
                        if (selectedNodeElement) {
                            selectedNodeElement.classList.remove('selected');
                        }
                        node.classList.add('selected');
                        selectedNodeElement = node;

                        showNodeProperties(person);
                    });
                });

                // Click on empty SVG area: deselect
                svgEl.addEventListener('click', function() {
                    if (selectedNodeElement) {
                        selectedNodeElement.classList.remove('selected');
                        selectedNodeElement = null;
                    }
                });
            }

            // --- Build tree ---
            async function buildTree(peopleArray) {
                if (!peopleArray.length) return;
                people = peopleArray;
                showStatus('‚è≥ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ñ–æ—Ç–æ...');
                await preloadPhotoChecks(people);
                showStatus('‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è DOT –∫–æ–¥–∞...');
                dotCode = await generateDotCode(people);
                graphvizOnlineBtn.disabled = false;
                updateInfoPanels();
                showStatus('‚è≥ –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞...');
                await renderDot(dotCode);
                showStatus('‚úÖ –î–µ—Ä–µ–≤–æ –ø–æ—Å—Ç—Ä–æ–µ–Ω–æ');
            }

            async function loadFromUrl(url) {
                try {
                    showStatus('‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...');
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = parseExcel(await response.arrayBuffer());
                    await buildTree(data);
                } catch (e) {
                    showStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + e.message, true);
                }
            }

            function loadFromFile(file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = parseExcel(e.target.result);
                        await buildTree(data);
                    } catch (err) {
                        showStatus('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: ' + err.message, true);
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            loadBtn.addEventListener('click', () => loadFromUrl('tree.xlsx'));
            manualBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) loadFromFile(e.target.files[0]);
                fileInput.value = '';
            });

            graphvizOnlineBtn.addEventListener('click', () => {
                if (graphvizLink) window.open(graphvizLink, '_blank');
            });

            loadFromUrl('tree.xlsx');
        })();
    </script>
</body>
</html>
