<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–µ–º–µ–π–Ω–æ–µ –¥—Ä–µ–≤–æ –Ω–∞ excel + Graphviz (—Å —Ñ–æ—Ç–æ)</title>
    <script src="https://unpkg.com/@viz-js/viz@3.4.0/lib/viz-standalone.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>üå≥ –°–µ–º–µ–π–Ω–æ–µ –¥—Ä–µ–≤–æ –Ω–∞ excel + Graphviz (—Å —Ñ–æ—Ç–æ)</h1>
        <div class="toolbar">
            <button id="loadBtn">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å tree.xlsx</button>
            <button id="manualBtn">üìÅ –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</button>
            <button id="graphvizOnlineBtn" disabled>üîó –ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ GraphvizOnline</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls">
        </div>
        <div id="status" class="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞...</div>

        <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ -->
        <div class="info-panels">
            <div class="panel" id="panel-link">
                <div class="panel-header" onclick="togglePanel('panel-link-content')">
                    <span>üîó –°—Å—ã–ª–∫–∞ –Ω–∞ GraphvizOnline</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-link-content">
                    <div class="link-box">
                        <input type="text" id="graphvizLinkInput" readonly value="(—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)" />
                        <button onclick="copyLink()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                    </div>
                </div>
            </div>

            <div class="panel" id="panel-placeholders">
                <div class="panel-header" onclick="togglePanel('panel-placeholders-content')">
                    <span>üñºÔ∏è –§–æ—Ç–æ –ø–µ—Ä—Å–æ–Ω</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-placeholders-content">
                    <div class="photos-grid" id="photosGrid">
                        <em style="color:#888">–ó–∞–≥—Ä—É–∑–∏—Ç–µ Excel –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–æ—Ç–æ</em>
                    </div>
                </div>
            </div>

            <div class="panel" id="panel-code">
                <div class="panel-header" onclick="togglePanel('panel-code-content')">
                    <span>üìÑ –ö–æ–¥ DOT</span>
                    <span class="toggle-icon">‚ñ∂</span>
                </div>
                <div class="panel-content" id="panel-code-content">
                    <textarea id="dotCodePre" class="dot-code">(–∫–æ–¥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)</textarea>
                    <div class="dot-code-toolbar">
                        <button onclick="refreshDiagramFromEditor()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Diagram panel: zoom container on top, zoom controls at bottom -->
        <div class="diagram-panel">
            <div class="diagram-panel-header">
                <span class="diagram-panel-title">üìä –î–∏–∞–≥—Ä–∞–º–º–∞</span>
            </div>
            <div class="zoom-container" id="zoomContainer">
                <div class="zoom-content" id="zoomContent">
                    <div id="graphvizContainer">–î–µ—Ä–µ–≤–æ –±—É–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–æ –∑–¥–µ—Å—å...</div>
                </div>
            </div>
            <div class="zoom-controls" id="zoom-controls">
                <button onclick="zoomIn()" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
                <span id="zoom-level">100%</span>
                <button onclick="zoomOut()" title="–£–º–µ–Ω—å—à–∏—Ç—å">‚àí</button>
                <button onclick="zoomReset()" title="–°–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—à—Ç–∞–±">–°–±—Ä–æ—Å</button>
                <button onclick="zoomFit()" title="–í–ø–∏—Å–∞—Ç—å –≤ –æ–∫–Ω–æ">–í–ø–∏—Å–∞—Ç—å</button>
            </div>
        </div>

        <footer>–§–æ—Ç–æ –∏–∑ –ø–∞–ø–∫–∏ <code>pic/</code> (idA.png). –£–∑–µ–ª: <code>image=</code>, <code>fixedsize=true</code>, <code>imagepos=tc</code>, <code>labelloc=b</code> ‚Äî —Ñ–æ—Ç–æ —Å–≤–µ—Ä—Ö—É, –∏–º—è –∏ –≥–æ–¥—ã —Å–Ω–∏–∑—É, –±–µ–∑ –Ω–∞–ª–æ–∂–µ–Ω–∏—è. –î–ª—è –º—É–∂—á–∏–Ω —Ä–∞–º–∫–∞ —Å–∏–Ω—è—è, –¥–ª—è –∂–µ–Ω—â–∏–Ω ‚Äî —Ä–æ–∑–æ–≤–∞—è.</footer>
    </div>

    <!-- Properties panels container (fixed positioning) -->
    <div id="properties-panels-container"></div>

    <script>
        (function() {
            let people = [];
            let dotCode = '';
            let graphvizLink = '';
            let currentScale = 1.0;

            // Properties panel state
            let openPropertiesPanels = [];
            let propertiesPanelCounter = 0;
            let selectedNodeElement = null;
            let draggedPanel = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            // Cache: filename -> true (exists) or false (not found)
            const photoExistsCache = {};

            // Node dimensions for Graphviz (in inches, at 72 DPI = 1 inch).
            // Will be overridden by config.json values if available.
            const PHOTO_SIZE_PX = 100;
            let NODE_WIDTH_IN = 2.0;
            let NODE_HEIGHT_IN = ((PHOTO_SIZE_PX + 32) / 72).toFixed(2) * 1; // ~1.83in

            const graphvizOnlineBtn = document.getElementById('graphvizOnlineBtn');
            const statusDiv = document.getElementById('status');
            const graphvizContainer = document.getElementById('graphvizContainer');
            const zoomContent = document.getElementById('zoomContent');
            const zoomContainer = document.getElementById('zoomContainer');
            const zoomLevelSpan = document.getElementById('zoom-level');
            const loadBtn = document.getElementById('loadBtn');
            const manualBtn = document.getElementById('manualBtn');
            const fileInput = document.getElementById('fileInput');
            const graphvizLinkInput = document.getElementById('graphvizLinkInput');
            const dotCodePre = document.getElementById('dotCodePre');

            // --- Load config.json ---
            async function loadConfig() {
                try {
                    const response = await fetch('config.json');
                    if (response.ok) {
                        const config = await response.json();
                        if (typeof config.nodeWidth === 'number' && config.nodeWidth > 0) {
                            NODE_WIDTH_IN = config.nodeWidth;
                        }
                        if (typeof config.nodeHeight === 'number' && config.nodeHeight > 0) {
                            NODE_HEIGHT_IN = config.nodeHeight;
                        }
                    }
                } catch (e) {
                    // config.json is optional; use defaults if not found
                }
            }

            // --- Panel toggling ---
            window.togglePanel = function(contentId) {
                const content = document.getElementById(contentId);
                const icon = content.previousElementSibling.querySelector('.toggle-icon');
                content.classList.toggle('visible');
                icon.textContent = content.classList.contains('visible') ? '‚ñº' : '‚ñ∂';
            };

            window.copyLink = function() {
                graphvizLinkInput.select();
                document.execCommand('copy');
                alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
            };

            // --- Zoom controls ---
            function applyZoom() {
                zoomContent.style.transform = `scale(${currentScale})`;
                zoomLevelSpan.textContent = Math.round(currentScale * 100) + '%';
            }

            window.zoomIn = function() {
                if (currentScale < 5.0) { currentScale = Math.min(5.0, currentScale + 0.1); applyZoom(); }
            };
            window.zoomOut = function() {
                if (currentScale > 0.1) { currentScale = Math.max(0.1, currentScale - 0.1); applyZoom(); }
            };
            window.zoomReset = function() {
                currentScale = 1.0;
                applyZoom();
            };
            window.zoomFit = function() {
                const svg = graphvizContainer.querySelector('svg');
                if (!svg) return;
                const containerW = zoomContainer.clientWidth - 20;
                const containerH = zoomContainer.clientHeight - 20;
                const svgW = svg.getBoundingClientRect().width / currentScale;
                const svgH = svg.getBoundingClientRect().height / currentScale;
                if (svgW <= 0 || svgH <= 0) return;
                const scaleX = containerW / svgW;
                const scaleY = containerH / svgH;
                currentScale = Math.min(scaleX, scaleY, 1.0);
                applyZoom();
            };

            // Mouse wheel zoom
            zoomContainer.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                currentScale = Math.min(5.0, Math.max(0.1, currentScale + delta));
                applyZoom();
            }, { passive: false });

            // --- Status ---
            function showStatus(msg, isError = false) {
                statusDiv.textContent = msg;
                statusDiv.style.backgroundColor = isError ? '#fadbd8' : '#fff8e5';
                statusDiv.style.borderLeftColor = isError ? '#e74c3c' : '#f1c40f';
            }

            // --- Check if photo exists via HEAD request ---
            async function checkPhotoExists(filename) {
                if (photoExistsCache[filename] !== undefined) return photoExistsCache[filename];
                try {
                    const response = await fetch('pic/' + filename, { method: 'HEAD' });
                    photoExistsCache[filename] = response.ok;
                    return response.ok;
                } catch {
                    photoExistsCache[filename] = false;
                    return false;
                }
            }

            // --- Determine which photo path to use for a person (returns path string or null) ---
            async function getPersonPhotoPath(person) {
                const personalFile = person.idA + '.png';
                if (await checkPhotoExists(personalFile)) return 'pic/' + personalFile;
                // Fall back to default
                const defaultFile = (person.sex === '–ñ' || person.sex === 'F') ? 'dafaultf.png' : 'dafaultm.png';
                if (await checkPhotoExists(defaultFile)) return 'pic/' + defaultFile;
                return null;
            }

            // --- Preload / check photo existence for all people ---
            async function preloadPhotoChecks(peopleList) {
                const filenames = new Set(['dafaultm.png', 'dafaultf.png']);
                peopleList.forEach(p => { if (p.idA) filenames.add(p.idA + '.png'); });
                await Promise.all(Array.from(filenames).map(fn => checkPhotoExists(fn)));
            }

            // --- Parse Excel ---
            function parseExcel(arrayBuffer) {
                try {
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const sheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('person')) || workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
                    if (rows.length < 2) throw new Error('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –ª–∏—Å—Ç–µ person');
                    const dataRows = rows.slice(1).filter(row => row[1] && row[1].toString().trim() !== '');
                    const peopleList = dataRows.map(row => ({
                        idA: row[0] ? row[0].toString().trim() : '',
                        label: row[1] ? row[1].toString().trim() : '',
                        sex: row[2] ? row[2].toString().trim() : '',
                        hasFather: row[4] ? row[4].toString().trim() : '',
                        hasMother: row[5] ? row[5].toString().trim() : '',
                        birth: row[6] ? row[6].toString().trim() : '',
                        death: row[7] ? row[7].toString().trim() : ''
                    })).filter(p => p.idA && p.label);
                    if (peopleList.length === 0) throw new Error('–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π —Å idA –∏ label');
                    return peopleList;
                } catch (e) {
                    showStatus('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ Excel: ' + e.message, true);
                    throw e;
                }
            }

            // --- Generate DOT code using native image= attribute ---
            // Each node is portrait-oriented: photo at top, text label at bottom.
            // Uses fixedsize=true with width/height so Graphviz reserves exact space.
            // imagepos=tc places photo at top-center; labelloc=b places text at bottom.
            // No <<TABLE>> labels ‚Äî readable plain DOT code only.
            // Spaces in label names are replaced with \n for better layout.
            async function generateDotCode(peopleList) {
                const nodes = [];
                const edges = [];
                const coupleSet = new Set();

                const maleColor = "#a3c4f3";
                const femaleColor = "#fbb9c0";
                const unknownColor = "#d5d8dc";

                for (const p of peopleList) {
                    const birthYear = p.birth || '?';
                    const deathYear = p.death || '?';

                    let fillcolor = unknownColor;
                    if (p.sex === '–ú' || p.sex === 'M') fillcolor = maleColor;
                    else if (p.sex === '–ñ' || p.sex === 'F') fillcolor = femaleColor;

                    const nodeId = p.idA;
                    // Replace spaces with \n in label for better node layout
                    const labelName = p.label.replace(/ /g, '\\n');
                    const labelText = `${labelName}\\n${birthYear}‚Äì${deathYear}`;

                    const photoPath = await getPersonPhotoPath(p);
                    if (photoPath) {
                        // Portrait node: photo at top-center at its registered size, text at bottom.
                        // fixedsize=true locks the node to exactly width√óheight so layout is consistent.
                        // imagescale=false keeps photo at registered PHOTO_SIZE_PX so it doesn't
                        // stretch over the text area; labelloc=b places text at bottom inside node.
                        nodes.push(`  ${nodeId} [shape=box, style="filled", fillcolor="${fillcolor}", color="#2c3e50",`);
                        nodes.push(`    label="${labelText}", image="${photoPath}",`);
                        nodes.push(`    fixedsize=true, width=${NODE_WIDTH_IN}, height=${NODE_HEIGHT_IN},`);
                        nodes.push(`    imagepos=tc, imagescale=false, labelloc=b];`);
                    } else {
                        nodes.push(`  ${nodeId} [shape=box, style="filled", fillcolor="${fillcolor}", color="#2c3e50", label="${labelText}"];`);
                    }
                }

                // Parent relationships
                peopleList.forEach(p => {
                    const childId = p.idA;
                    if (p.hasFather) edges.push(`  ${p.hasFather} -> ${childId};`);
                    if (p.hasMother) edges.push(`  ${p.hasMother} -> ${childId};`);
                    if (p.hasFather && p.hasMother) {
                        const key = p.hasFather < p.hasMother ? `${p.hasFather}|${p.hasMother}` : `${p.hasMother}|${p.hasFather}`;
                        coupleSet.add(key);
                    }
                });

                // Couple links
                coupleSet.forEach(couple => {
                    const [a, b] = couple.split('|');
                    edges.push(`  ${a} -> ${b} [dir=none, color="#5d6d7e"];`);
                });

                return `digraph G {\n  rankdir=TB;\n  node [fontname="Arial", fontsize=11];\n  edge [color="#5d6d7e"];\n\n${nodes.join('\n')}\n\n${edges.join('\n')}\n}`;
            }

            // --- Build images array for viz.renderString() images option ---
            // Collects all unique photo paths used in the DOT code and registers them
            // with square dimensions matching the node width so the photo fills the top portion.
            async function buildImagesOption(peopleList) {
                const imageMap = new Map(); // path -> true (deduplicate)
                for (const p of peopleList) {
                    const photoPath = await getPersonPhotoPath(p);
                    if (photoPath) imageMap.set(photoPath, true);
                }
                return Array.from(imageMap.keys()).map(path => ({
                    name: path,
                    width: PHOTO_SIZE_PX,
                    height: PHOTO_SIZE_PX
                }));
            }

            // --- Render DOT code ---
            async function renderDot(dotStr, imagesOption) {
                try {
                    const viz = await Viz.instance();
                    const svgStr = await viz.renderString(dotStr, {
                        format: 'svg',
                        images: imagesOption
                    });
                    graphvizContainer.innerHTML = svgStr;

                    // Add node click handlers
                    const svgEl = graphvizContainer.querySelector('svg');
                    if (svgEl) {
                        addNodeClickHandlers(svgEl);
                    }
                } catch (error) {
                    graphvizContainer.innerHTML = `<p style="color:red">–û—à–∏–±–∫–∞ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞: ${error.message}</p>`;
                    console.error(error);
                }
            }

            // --- Refresh diagram from DOT editor ---
            window.refreshDiagramFromEditor = async function() {
                const editedDot = dotCodePre.value;
                if (!editedDot || editedDot === '(–∫–æ–¥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)') return;
                showStatus('‚è≥ –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã...');
                dotCode = editedDot;
                // Update graphviz link
                const encoded = encodeURIComponent(dotCode);
                graphvizLink = `https://dreampuf.github.io/GraphvizOnline/?engine=dot#${encoded}`;
                graphvizLinkInput.value = graphvizLink;
                // Re-render without re-loading images (use already loaded people)
                const imagesOption = await buildImagesOption(people);
                await renderDot(dotCode, imagesOption);
                showStatus('‚úÖ –î–∏–∞–≥—Ä–∞–º–º–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞');
            };

            // --- Update photos panel ---
            // Shows only files that actually exist in pic/ folder (no empty placeholders).
            function updatePhotosPanel() {
                const grid = document.getElementById('photosGrid');
                grid.innerHTML = '';

                // Build list of files that were checked and found to exist
                const existingFiles = [];

                // Always include defaults if they exist
                for (const fn of ['dafaultm.png', 'dafaultf.png']) {
                    if (photoExistsCache[fn]) existingFiles.push(fn);
                }

                // Add person photos that exist
                people.forEach(p => {
                    const fn = p.idA + '.png';
                    if (photoExistsCache[fn] && !existingFiles.includes(fn)) {
                        existingFiles.push(fn);
                    }
                });

                if (existingFiles.length === 0) {
                    grid.innerHTML = '<em style="color:#888">–§–∞–π–ª—ã —Ñ–æ—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –ø–∞–ø–∫–µ pic/</em>';
                    return;
                }

                existingFiles.forEach(filename => {
                    const div = document.createElement('div');
                    div.className = 'photo-item';

                    const img = document.createElement('img');
                    img.src = 'pic/' + filename;
                    img.alt = filename;
                    img.title = filename;

                    const label = document.createElement('div');
                    label.className = 'path';
                    const shortName = filename.length > 20 ? filename.substring(0, 18) + '‚Ä¶' : filename;
                    label.textContent = shortName;
                    label.title = filename;

                    div.appendChild(img);
                    div.appendChild(label);
                    grid.appendChild(div);
                });
            }

            // --- Update info panels ---
            function updateInfoPanels() {
                if (dotCode) {
                    dotCodePre.value = dotCode;
                    const encoded = encodeURIComponent(dotCode);
                    graphvizLink = `https://dreampuf.github.io/GraphvizOnline/?engine=dot#${encoded}`;
                    graphvizLinkInput.value = graphvizLink;
                } else {
                    dotCodePre.value = '(–∫–æ–¥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)';
                    graphvizLinkInput.value = '(—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)';
                }
                updatePhotosPanel();
            }

            // ================================================================
            // PROPERTIES PANEL (–°–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã)
            // Based on rdf-grapher ver9d implementation
            // ================================================================

            function showNodeProperties(person) {
                const container = document.getElementById('properties-panels-container');
                if (!container) return;

                // If already open for this person, bring to front
                const existingPanel = openPropertiesPanels.find(p => p.idA === person.idA);
                if (existingPanel) {
                    const panel = document.getElementById(existingPanel.panelId);
                    if (panel) bringPanelToFront(panel);
                    return;
                }

                propertiesPanelCounter++;
                const panelId = 'properties-panel-' + propertiesPanelCounter;

                const offsetMultiplier = openPropertiesPanels.length % 5;
                const rightOffset = 20 + (offsetMultiplier * 30);
                const topOffset = 100 + (offsetMultiplier * 30);

                // Build properties content
                const sex = person.sex || '‚Äî';
                const birth = person.birth || '‚Äî';
                const death = person.death || '‚Äî';
                const photoFile = photoExistsCache[person.idA + '.png'] ? person.idA + '.png' : null;

                let propertiesHtml = '';
                propertiesHtml += `<div class="property-item"><div class="property-predicate">ID</div><div class="property-value">${person.idA}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ò–º—è</div><div class="property-value">${person.label}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ü–æ–ª</div><div class="property-value">${sex}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ì–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è</div><div class="property-value">${birth}</div></div>`;
                propertiesHtml += `<div class="property-item"><div class="property-predicate">–ì–æ–¥ —Å–º–µ—Ä—Ç–∏</div><div class="property-value">${death}</div></div>`;
                if (person.hasFather) {
                    const father = people.find(p => p.idA === person.hasFather);
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–û—Ç–µ—Ü</div><div class="property-value">${father ? father.label : person.hasFather}</div></div>`;
                }
                if (person.hasMother) {
                    const mother = people.find(p => p.idA === person.hasMother);
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–ú–∞—Ç—å</div><div class="property-value">${mother ? mother.label : person.hasMother}</div></div>`;
                }
                if (photoFile) {
                    propertiesHtml += `<div class="property-item"><div class="property-predicate">–§–æ—Ç–æ</div><div class="property-value photo"><img src="pic/${photoFile}" alt="${person.label}"></div></div>`;
                }

                const escapedLabel = person.label.replace(/'/g, "\\'").replace(/"/g, '&quot;');

                const panelHtml = `
                    <div class="properties-panel visible" id="${panelId}" style="right: ${rightOffset}px; top: ${topOffset}px;">
                        <div class="properties-header" onmousedown="startDragPanel(event, '${panelId}')">
                            <div class="properties-header-content">
                                <div class="properties-header-title">–°–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã</div>
                                <h3>${person.label}</h3>
                                <button class="properties-copy-btn" onclick="event.stopPropagation(); copyObjectId('${escapedLabel}', this)">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                            </div>
                            <button class="properties-close-btn" onclick="closePropertiesPanel('${panelId}')">&times;</button>
                        </div>
                        <div class="properties-content">
                            ${propertiesHtml}
                        </div>
                    </div>
                `;

                container.insertAdjacentHTML('beforeend', panelHtml);
                openPropertiesPanels.push({ panelId: panelId, idA: person.idA });

                const newPanel = document.getElementById(panelId);
                if (newPanel) bringPanelToFront(newPanel);
            }

            window.closePropertiesPanel = function(panelId) {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.remove();
                    openPropertiesPanels = openPropertiesPanels.filter(p => p.panelId !== panelId);
                }
                if (selectedNodeElement) {
                    selectedNodeElement.classList.remove('selected');
                    selectedNodeElement = null;
                }
            };

            window.copyObjectId = function(label, btn) {
                navigator.clipboard.writeText(label).then(() => {
                    const orig = btn.textContent;
                    btn.textContent = '‚úì';
                    setTimeout(() => { btn.textContent = orig; }, 1500);
                }).catch(() => {
                    // Fallback
                    const el = document.createElement('textarea');
                    el.value = label;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                });
            };

            function bringPanelToFront(panel) {
                let maxZIndex = 2000;
                openPropertiesPanels.forEach(p => {
                    const el = document.getElementById(p.panelId);
                    if (el) {
                        const z = parseInt(el.style.zIndex) || 2000;
                        if (z > maxZIndex) maxZIndex = z;
                    }
                });
                panel.style.zIndex = maxZIndex + 1;
            }

            window.startDragPanel = function(event, panelId) {
                if (event.target.classList.contains('properties-close-btn') ||
                    event.target.classList.contains('properties-copy-btn')) return;
                const panel = document.getElementById(panelId);
                if (!panel) return;

                draggedPanel = panel;
                const rect = panel.getBoundingClientRect();
                dragOffsetX = event.clientX - rect.left;
                dragOffsetY = event.clientY - rect.top;

                bringPanelToFront(panel);
                document.addEventListener('mousemove', dragPanel);
                document.addEventListener('mouseup', stopDragPanel);
                event.preventDefault();
            };

            function dragPanel(event) {
                if (!draggedPanel) return;
                const newLeft = event.clientX - dragOffsetX;
                const newTop = event.clientY - dragOffsetY;
                draggedPanel.style.left = newLeft + 'px';
                draggedPanel.style.top = newTop + 'px';
                draggedPanel.style.right = 'auto';
            }

            function stopDragPanel() {
                draggedPanel = null;
                document.removeEventListener('mousemove', dragPanel);
                document.removeEventListener('mouseup', stopDragPanel);
            }

            // --- Add node click handlers to rendered SVG ---
            function addNodeClickHandlers(svgEl) {
                const nodes = svgEl.querySelectorAll('g.node');
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    node.addEventListener('click', function(event) {
                        event.stopPropagation();

                        const titleEl = node.querySelector('title');
                        if (!titleEl) return;
                        const nodeId = titleEl.textContent.trim();
                        const person = people.find(p => p.idA === nodeId);
                        if (!person) return;

                        // Update selection highlight
                        if (selectedNodeElement) {
                            selectedNodeElement.classList.remove('selected');
                        }
                        node.classList.add('selected');
                        selectedNodeElement = node;

                        showNodeProperties(person);
                    });
                });

                // Click on empty SVG area: deselect
                svgEl.addEventListener('click', function() {
                    if (selectedNodeElement) {
                        selectedNodeElement.classList.remove('selected');
                        selectedNodeElement = null;
                    }
                });
            }

            // --- Build tree ---
            async function buildTree(peopleArray) {
                if (!peopleArray.length) return;
                people = peopleArray;
                showStatus('‚è≥ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ñ–æ—Ç–æ...');
                await preloadPhotoChecks(people);
                showStatus('‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è DOT –∫–æ–¥–∞...');
                dotCode = await generateDotCode(people);
                graphvizOnlineBtn.disabled = false;
                updateInfoPanels();
                showStatus('‚è≥ –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞...');
                const imagesOption = await buildImagesOption(people);
                await renderDot(dotCode, imagesOption);
                showStatus('‚úÖ –î–µ—Ä–µ–≤–æ –ø–æ—Å—Ç—Ä–æ–µ–Ω–æ');
            }

            async function loadFromUrl(url) {
                try {
                    showStatus('‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...');
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = parseExcel(await response.arrayBuffer());
                    await buildTree(data);
                } catch (e) {
                    showStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + e.message, true);
                }
            }

            function loadFromFile(file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = parseExcel(e.target.result);
                        await buildTree(data);
                    } catch (err) {
                        showStatus('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: ' + err.message, true);
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            loadBtn.addEventListener('click', () => loadFromUrl('tree.xlsx'));
            manualBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) loadFromFile(e.target.files[0]);
                fileInput.value = '';
            });

            graphvizOnlineBtn.addEventListener('click', () => {
                if (graphvizLink) window.open(graphvizLink, '_blank');
            });

            // Load config first, then start loading tree data
            loadConfig().then(() => loadFromUrl('tree.xlsx'));
        })();
    </script>
</body>
</html>
